## 2025-05-14 - [Video Control Logic] **Learning:** Synchronizing React state with imperative browser APIs (like HTML5 Video) requires careful use of `useRef` and `useEffect`. Modern browsers block `play()` calls without user interaction, so the "unhappy path" must always be handled with a `.catch()` block. **Action:** Always wrap `mediaElement.play()` in a try/catch or promise catch to prevent uncaught rejections and sync UI state accordingly.

## 2025-05-15 - [Signaling State Integrity] **Learning:** In P2P signaling systems, identity (username) must be tied to the socket session at the moment of room entry. Storing the username on the socket instance during `join-stream` ensures that subsequent room events (`user-connected`, `user-disconnected`) can propagate meaningful identity data without redundant lookups. Redundant joins should be handled on the backend to prevent duplicate signaling events caused by React component remounting or multiple components sharing a single socket. **Action:** Always validate room state on the backend before emitting join/leave notifications.

## 2025-05-16 - [Signaling Security & Test Stability] **Learning:** WebRTC signaling events must validate that both sender and recipient reside in the same room to prevent unauthorized cross-room communication. Additionally, to avoid `EADDRINUSE` errors in concurrent backend test environments, Socket.io servers should bind to dynamic ports (port 0) and expose the assigned port to test clients via `server.address().port`. **Action:** Enforce room-affinity for all signaling relay logic and use dynamic port binding in all server-based test suites.

## 2025-05-17 - [Complete Signaling Security] **Learning:** Security validations must be applied to all conduits of aing specific protocol, not just the named ones. In Socket.io signaling, a generic 'signal' catch-all can bypass protections on specific events like 'offer' or 'answer' if it lacks identical room-affinity validation. **Action:** When securing a communication channel, identify all event types that can relay similar payloads and apply uniform validation logic across all of them.

## 2025-05-18 - [Real-time Balance Sync & State Cleanup] **Learning:** Real-time wallet balance synchronization across multiple tabs or concurrent connections is most reliably achieved using a dedicated Socket.io room per user identity (`user:${username}`). This ensures that any transaction affecting a user's balance propagates to all their active sessions. Additionally, in-memory stream metadata (like revenue-split squads) must be explicitly cleared during host `disconnect` or `leave-stream` events to prevent memory leaks and ensure logic integrity for subsequent sessions. **Action:** Implement dedicated user rooms for cross-tab synchronization and enforce strict cleanup of session-scoped memory Maps on user departure.
